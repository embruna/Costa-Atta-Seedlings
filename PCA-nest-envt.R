# #PCA of environmental data in R
# Used http://www.r-bloggers.com/computing-and-visualizing-pca-in-r/ as a guide


library(devtools)
#install_github("ggbiplot", "vqv")
library(ggbiplot)
library(dplyr)
library(tidyr)

#CLear out everything from the environment
rm(list=ls())

##################
#################
###DATA ENTRY AND CLEANUP
##################
#################
#Step 1: load the individual CSV files and save them as dataframes
setwd("/Users/emiliobruna/Dropbox/Alan/Data/Capitulo2")
NEST.DATA<-read.csv("ActiveNests_data_2-3-4-5-6.csv", dec=".", header = TRUE, sep = ",", check.names=FALSE )
#make plot locations an ordered factor nest<adjacent<far
NEST.DATA$location=factor(NEST.DATA$location, levels=c("nest","adjacent", "far"), ordered=TRUE)

head(NEST.DATA, 3)
str(NEST.DATA)

# #Select only Cerrado Denso and Cerrado Ralo
NEST.DATA.both<-filter(NEST.DATA, habitat =="CD" | habitat == "CR")
# #Select only Cerrado Denso 
NEST.DATA.CD<-filter(NEST.DATA, habitat =="CD")
#Select only Cerrado Ralo
NEST.DATA.CR<-filter(NEST.DATA, habitat == "CR")
# 
# Which of the habitats are you going to analyze? CD, CR, or both?
NEST.DATA.PCA<-NEST.DATA.both #NEST.DATA.CD NEST.DATA.both NEST.DATA.CR 
#Delete the ones with missing values. 
#Note there are techniques to impute missing values can look into 
NEST.DATA.PCA<-na.omit(NEST.DATA.PCA) 
# log transform 
# env.vars <- log(NEST.DATA.PCA[, 5:18]+1)
# no transformation as per HLV
env.vars <- NEST.DATA.PCA[,5:18]
site.cats <- NEST.DATA.PCA[, 1:5]

# Exclude the following: grass biomass, canopy.cover, deep soil humidity 
env.vars$grass.bmass<-NULL
env.vars$humid.soil.deep<-NULL
env.vars$peak.soil.temp<-NULL



# apply PCA - scale. = TRUE is highly advisable, but default is FALSE. 
nest.env.pca <- prcomp(env.vars,
                 center = TRUE,
                 scale. = TRUE) 

#Visualizing the results.
# The print method returns the standard deviation of each of the four PCs, 
# and their rotation (or loadings), which are the coefficients of the linear combinations of the continuous variables.
print(nest.env.pca)


# The Figure below is useful to decide how many PCs to retain for further analysis. 
# I.E., which PCs explain most of the variability in the data.
plot(nest.env.pca, type = "l")

# The summary method describe the importance of the PCs. 
# The first row describe again the standard deviation associated with each PC. 
# The second row shows the proportion of the variance in the data explained by each component.
# The third row describe the cumulative proportion of explained variance. 
# summary method
summary(nest.env.pca)




# The Figure below is a biplot generated by the function ggbiplot of the ggbiplot package available on https://github.com/vqv/ggbiplot
# TO install: 
# library(devtools)
# install_github("ggbiplot", "vqv")
# library(ggbiplot)
# ?ggbiplot for more info on arguments you can change and % used to draw ellipses aroudnd points

habitat<-site.cats$location
cover<-site.cats$perc.cover
point.size<-cover*0.1
g <- ggbiplot(nest.env.pca, obs.scale = 1, var.scale = 1, 
              group = habitat, ellipse = TRUE, 
              circle = TRUE, varname.size=3)+
  scale_colour_manual(values=c("darkred", "darkblue")) +
#geom_point(size=point.size)  #Scaling the size of the point by canopy cover. 100% canopy cover=point size = 6.  That is why each % is multiplied by 0.06
geom_point(aes(color=habitat, size = point.size)) + scale_size_identity()
#I chose my own colors for the lines
g<-g + scale_x_continuous(breaks = seq(-4, 4, 2), limits = c(-5, 4)) # I adjusted X axis so that I could read the larger labels on arrows
g<-g + scale_y_continuous(breaks = seq(-4, 4, 2), limits = c(-4,4)) # I adjusted Y axis so that I could read the larger labels on arrows


g <- g + theme_classic()+theme(legend.direction = 'horizontal', 
                legend.position = 'top',
                axis.title.x=element_text(colour="black", size = 18, vjust=-0.5),            #sets x axis title size, style, distance from axis #add , face = "bold" if you want bold
                axis.title.y=element_text(colour="black", size = 18, vjust=2),            #sets y axis title size, style, distance from axis #add , face = "bold" if you want bold
                axis.text=element_text(colour="black", size = 16),                             #sets size and style of labels on axes
                legend.title = element_blank(), #remove title of legend
                legend.text = element_text(color="black", size=22, vjust =2),
                plot.margin =unit(c(1,1,1,1.5), "lines")) +  #plot margin - top, right, bottom, left
                guides(colour=guide_legend(override.aes=list(size=4, linetype=0)))  #size of legen bars    

print(g)


#########################################
## ANALYSES BASED ON PCA
#########################################

#nest.env.pca$x =  scores for each of the plots for each PCA


pca.plot.scores<-(nest.env.pca$x) #this saves the matrix of PCA scores (all axes) for all plots 
PCA.1<-as.data.frame(pca.plot.scores[,1]) #this saves the 1st column - PCA Axis 1 - as a dataframe
PCA.2<-pca.plot.scores[,2]#this saves the 2nd column - PCA Axis 2 - as a dataframe
GLM.DATA<-as.data.frame(cbind(habitat, cover, PCA.1, PCA.2))
names(GLM.DATA)[3]<-"PCA1" #reaname the column
names(GLM.DATA)[4]<-"PCA2" #rename the column

# Nice overview of GLMs here: http://plantecology.syr.edu/fridley/bio793/glm.html

#################
## FOR PCA AXIS 1
#################

# GLM to these data with just an intercept (overall mean):
glm1 = glm(PCA1~1,,family = gaussian, data = GLM.DATA)
summary(glm1)

# add a continuous predictor variable, fit the new glm and test it against a model with only an intercept:
glm2 = glm(PCA1 ~ habitat ,data=GLM.DATA,family=gaussian)
anova(glm1,glm2,test="Chisq")
#Result: model 2 better fit

#Add Percent cover as a covariate
glm3 = glm(PCA1 ~ habitat + cover,data=GLM.DATA,family=gaussian)
summary(glm3)
anova(glm2,glm3,test="Chisq")
# looks like including cover is better than just habitat

# Is there an interaction?
glm4 = glm(PCA1 ~ habitat * cover,data=GLM.DATA,family=gaussian) #Recall * is syntax syntax shortcue of both main effects + interaction
summary(glm4)
anova(glm3,glm4,test="Chisq")
#Doesn't look like including interaction provides better fit

AIC(glm1, glm2,glm3,glm4)

#################
## FOR PCA AXIS 2
#################

# GLM to these data with just an intercept (overall mean):
glm1b = glm(PCA2~1,,family = gaussian, data = GLM.DATA)
summary(glm1b)

# add a continuous predictor variable, fit the new glm and test it against a model with only an intercept:
glm2b = glm(PCA2 ~ habitat ,data=GLM.DATA,family=gaussian)
anova(glm1b,glm2b,test="Chisq")
#Result: Nope

#Add Percent cover as a covariate
glm3b = glm(PCA2 ~ habitat + cover,data=GLM.DATA,family=gaussian)
summary(glm3b)
anova(glm1b,glm2b,test="Chisq")
# nope - not better than just intercept

# Is there an interaction?
glm4b = glm(PCA2 ~ habitat * cover,data=GLM.DATA,family=gaussian) #Recall * is syntax syntax shortcue of both main effects + interaction
summary(glm4b)
anova(glm1b,glm4b,test="Chisq")
#Doesn't look 

AIC(glm1b, glm2b,glm3b,glm4b)

#################
## PLOTS of PCA scores v Canopy COver, etc.
#################

PCAfigData<-gather(GLM.DATA, "Axis", "PCA.Score", 3:4)

# my_grob_ENV1 = grobTree(textGrob("A", x=0.05,  y=.95, gp=gpar(col="black", fontsize=18, fontface="bold")))


PCAfig<-ggplot(PCAfigData, aes(x=cover, y=PCA.Score, col=habitat, fill=habitat)) + 
  geom_point(shape=16, size=3)+
  #   facet_grid(variable ~ .)+
  facet_wrap(~Axis,nrow = 2,scales = "free")+
  ylab("PCA Score") +  
  xlab("Canopy cover (%)")+
  geom_smooth(method=lm,se=FALSE)   # Add linear regression lines, Don't add shaded confidence region
# +annotation_custom(my_grob_ENV1)
PCAfig<-PCAfig + scale_colour_manual(values=c("blue", "red"))  #I chose my own colors for the lines
PCAfig<-PCAfig + scale_y_continuous(breaks = seq(-4, 4, 1), limits = c(-4.5, 4.5))
PCAfig<-PCAfig + scale_x_continuous(breaks = seq(0, 100, 10), limits = c(0, 100))
# 


PCAfig<- PCAfig + theme_classic()+
  theme(plot.title = element_text(face="bold", size=18, vjust=-3.5, hjust=0.05),        #Sets title size, style, location
        axis.title.x=element_text(colour="black", size = 18, vjust=-0.5),            #sets x axis title size, style, distance from axis #add , face = "bold" if you want bold
        axis.title.y=element_text(colour="black", size = 18, vjust=2),            #sets y axis title size, style, distance from axis #add , face = "bold" if you want bold
        axis.text=element_text(colour="black", size = 16),                             #sets size and style of labels on axes
        panel.margin = unit(2, "lines"), #space between facets
        axis.line = element_line(colour = "black"), #sets colors of axes
        legend.title = element_blank(),   #Removes the Legend title
        legend.text = element_text(color="black", size=16),
        legend.position = c(0.9,0.95),
        strip.text.x = element_text(size=18, colour="black", face="bold", vjust=-1.4, hjust=.05),
        strip.background = element_blank(),
        legend.background = element_rect(colour = 'black', size = 0.5, linetype='solid'), #box around legend
        plot.margin =unit(c(0,1,2,1.5), "cm")) +  #plot margin - top, right, bottom, left
  guides(colour=guide_legend(override.aes=list(size=4, linetype=0)))  #size of legen bars    

PCAfig



# for quesiton on dot colors posted on stack overflow
# http://stackoverflow.com/questions/30968563/ggbiplot-how-to-maintain-group-colors-after-changing-point-size

env.vars<-data.frame(replicate(5,sample(0:10,20,rep=TRUE)))
cover<-c(89, 92, 72, 53, 88, 89, 71, 83, 71, 66, 23, 30,  5, 15, 57, 54,0, 23, 9, 16)
habitat<-c("habitat1", "habitat2", "habitat1", "habitat2", "habitat1", "habitat2", "habitat1", "habitat2", "habitat1", "habitat2", "habitat1", "habitat2", "habitat1", "habitat2", "habitat1", "habitat2", "habitat1", "habitat2", "habitat1", "habitat2")
point.size<-cover*0.1